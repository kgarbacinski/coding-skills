import os
import shutil
import time

from .language_specs import LanguageSpecs


class ContainerHandler:
    """
    This class generates and manages Docker container lifecycle where test code is executed.

    Attributes: 
        language: string value taken from a user in frontend.
        container_name: unique container name generated by caller class.
        language_specs: based on the language choice from frontend gets a language extension and configutation. 

    Methods: 
        run_container(): runs docker container with predefined image env (based on a language chosen).
        run_compiler(): runs remote code execution in container based on the language settings.
        stop_container(): kills generated container. 

    """
    def __init__(self, language: str, container_name: str) -> None:
        self.__language_specs = LanguageSpecs()
        self.__language = language
        self.__file_extension = self.__language_specs.language_extensions.get(self.__language)
        self.__imageURL = f'dyeroshenko/coding_challenges_{self.__file_extension}_env'
        self.__container_name = container_name

    def run_container(self) -> None:
        start_container = f'docker run -d --name {self.__container_name} -v $PWD/checker/temp/result_files:/result {self.__imageURL} sleep 1000'
        os.system(start_container)
        print(f'====> Started container: {self.__container_name}')

    def run_compiler(self) -> None:
        compilers = self.__language_specs.language_compilers.get(self.__language)

        for index, compiler in enumerate(compilers):
            if index > 0:
                task = f"docker exec -d {self.__container_name} {compiler} /{self.__file_extension}_image/exec_files/Validator"
                os.system(task)
                print(f'====> Run task: {task}')
            else:
                task = f"docker exec -d {self.__container_name} {compiler} /{self.__file_extension}_image/exec_files/Validator.{self.__file_extension}"
                os.system(task)
                print(f'====> Run task: {task}')

    def stop_container(self) -> None:
        stop_container = f'docker stop {self.__container_name} && docker rm {self.__container_name}'
        os.system(stop_container)
        print(f'====> Container stopped & removed: {self.__container_name}')


class FilesHandler:
    """
    This class takes input from frontend, generates / moves files with code to be executed remotly.
    Generated files are temporarly stored in ./temp/ and then moved to container for remote execution.

    Attributes: 
        input: string value from the database. Exercise input.
        output: string value from the database. Exercise output.
        code: string value from the frontend. Exercise solution in chosen language typed by user.
        language: string value taken from the user in the frontend.
        container_name: unique container name generated by caller class.
        language_specs: based on the language choice from the frontend gets language extension and configutation. 

    Methods: 
        generate_code_validation(): reads validation code from /configs/ and saves it to file with extension based on user decision (.java, .py, etc).
        generate_submitted_code_file(): takes the input from user in frontend and saves it to files with chosen language extension.
        generate_testng_values_file(): reads values taken from the DB (exercise input and output) and writes to .xml.
            XML format was chosen as a common one between Python, Java and Node (Java doesn't support JSON from the box :\ ).
        generate_all_files(): creates temp/exec_files/ folder and saves all the files from above to this folder.
        copy_files_to_container(): gets files from temp/exec_files/ and send to container.
        copy_result_from_container(): executes generated files remotely in a container and copies result.txt file locally to /temp/result_files.
        get_result_value(): reads generated value from result.txt
        cleanup_temp_files(): deletes all generated files under temp/ with 3 seconds delay (implemented for threading delay).

        Callers: 
            ExecuteTest
    """
    def __init__(self, input: str, output: str, code: str, language:str, container_name: str) -> None:
        self.__input = input
        self.__output = output
        self.__code = code
        self.__language = language
        self.__language_specs = LanguageSpecs()
        self.__file_extension = self.__language_specs.language_extensions.get(self.__language)
        self.__code_validator = open(self.__language_specs.code_validators.get(self.__language), 'r').read()
        self.__xml_template = open(self.__language_specs.xml_template, 'r').read()
        self.__exec_folder_path = os.path.join(os.getcwd(), f'checker/temp/exec_files')
        self.__result_folder_path = os.path.join(os.getcwd(), f'checker/temp/result_files')
        self.__container_name = container_name

    def __generate_code_validation_file(self) -> None:
        file_name = f'{self.__exec_folder_path}/Validator.{self.__file_extension}'

        with open(file_name, 'w+') as file:
            file.write(self.__code_validator)

        print('====> Created [code_validation_file]')

    def __generate_submitted_code_file(self) -> None:
        file_name = f'{self.__exec_folder_path}/Solution.{self.__file_extension}'

        with open(file_name, 'w+') as file:
            file.write(self.__code)

        print('====> Created [submitted_code_file]')

    def __generate_testing_values_file(self) -> None:
        values = self.__xml_template.replace(
            'INPUT_VALUE', self.__input).replace(
                'OUTPUT_VALUE', self.__output)
                
        file_name = f'{self.__exec_folder_path}/input_values.xml'
        
        with open(file_name, 'w+') as file:
            file.write(values)

        print('====> Created [values_file]')

    def generate_all_files(self) -> None:
        os.mkdir(self.__exec_folder_path)
        self.__generate_code_validation_file()
        self.__generate_submitted_code_file()
        self.__generate_testing_values_file()

        print('====> All files are generated')

    def copy_files_to_container(self) -> None:
        copy_files_to_container = f'docker cp {self.__exec_folder_path} {self.__container_name}:{self.__file_extension}_image'
        os.system(copy_files_to_container)

        print('====> Files added to container')

    def copy_result_from_container(self) -> None:
        get_generated_result = f'docker cp {self.__container_name}:/{self.__file_extension}_image/exec_files/result_{self.__file_extension}.txt {self.__result_folder_path}'
        os.system(get_generated_result)

        print('====> Files copied from container')

    def get_result_value(self) -> str:
        print('====> Trying to read result from container')
        file_path = f'checker/temp/result_files/result_{self.__file_extension}.txt'

        try: 
            with open(file_path, 'r') as file:
                result = file.read()
                print(f'====> Result is available: {result}')
                return result
        except FileNotFoundError:
            print(f'====> Code was not compiled in container.')
            return 'unable to compile'

    def cleanup_temp_files(self) -> None:
        time.sleep(3)
        shutil.rmtree(self.__exec_folder_path)
        shutil.rmtree(self.__result_folder_path)
        print('====> Files are removed')
        